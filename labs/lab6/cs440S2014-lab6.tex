%!TEX root=cs440S2014-lab6.tex 
% mainfile: cs440S2014-lab6.tex 

\input{labspre.tex}

\usepackage[compact]{titlesec}

\begin{document} \MYTITLE{Laboratory Assignment Six: Measuring the Size of Program Variables in Java and C}
\MYHEADERS{Laboratory Assignment Six}{Due: March 31, 2014}

% \vspace*{-.32in}

\section*{Introduction}

  Main memory, in the form of random-access memory (RAM), is an important component of a computer.  The memory management
  unit (MMU) of an operating system is responsible for allocating, deallocating, and compressing the memory required by
  the programs that the operating system is managing. One of the first steps towards understanding the management of
  memory is to learn more about the size of the primitive variables that programs ask the MMU to allocate to memory. In
  this laboratory assignment, you will write a C and a Java program to determine the size of the most prevalently used
  primitive types supported by these two languages. 

\section*{Sizing Variables in a C Program}

  The C programming language provides a {\tt sizeof} method that a program can use to determine the size of a primitive
  variable like an {\tt int}. What are the inputs and outputs of the {\tt sizeof} function? How does the {\tt sizeof}
  function work? You should write a {\tt usesizeof.c} program and use the {\tt gcc} compiler to build a binary called
  {\tt usesizeof}. Your program should calculate the size, in both bits and bytes, of the following variable types: {\tt
  short}, {\tt int}, {\tt long}, {\tt long long}, {\tt float}, {\tt double}, {\tt long double}, {\tt char}, {\tt char*},
  and {\tt \_Bool}. Do the sizes reported by your program make sense? Why?

\section*{Sizing Variables in a Java Program}

  While the Java language specification states that all primitive types should be uniform across implementations of the
  compiler and virtual machine, it is still worthwhile to determine the size of primitives in this language. However,
  the Java language does not provide a {\tt sizeof} method like the one that you used in your C program. To learn more
  about how to calculate the size of a Java primitive, read the article called ``Sizeof for java: object sizing
  revisited'' by Vladimir Roubtsov. In the downloads section of this online article, you will find a Zip file called
  {\tt 02-qa-1226-sizeof.zip}. 

  After downloading this file, decompress it in the directory that you are using to store the files for this laboratory
  assignment. Using the example source code provide with this archive, you should write a Java program called {\tt
  UseSizeOf.java} that calculates the size, in both bits and bytes, of the following variable types:  {\tt short}, {\tt
  int}, {\tt long}, {\tt float}, {\tt double}, {\tt boolean}, and {\tt char}. Don't forget that {\tt UseSizeof.java}
  will not compile and the program will not run unless you have {\tt objectprofiler.jar} in your {\tt CLASSPATH}
  environment variable. 
  
  When you analyze the output of the {\tt UseSizeof} program, you should take into account that Java's autoboxing
  feature will transform your primitive types into objects.  As such, your final output needs to consider the size of a
  reference pointer. What are the final sizes reported by your program? Do they make sense? Why? How do they compare to
  the sizes of the C variables?

\section*{Analysis of the Sizing Results}

  

\section*{Summary of the Required Deliverables}

This assignment invites you to submit printed and signed versions of the following deliverables: 

\begin{enumerate}

  \itemsep0in

  \item A screenshot demonstrating that you were able to correctly configure and use the simulator

  \item All of the {\tt .dat} files used in the simulation studies that you conducted your experiments

  \item A comprehensive report on all of the runs of the scheduling simulator that includes:

  \begin{enumerate}

  \itemsep0in
    \item A clear description the behavior of each of the scheduling algorithms
    \item A commentary on how preemption and prioritization influences scheduling decisions
    \item A formal definition of the evaluation metrics used in your study
    \item A description of the job workloads used during the simulations
    \item A detailed analysis of the results from running the scheduler simulations
    \item A statement of which scheduling algorithm is best suited for a modern operating system

  \end{enumerate}

  \item A reflective discussion of the challenges that you encountered when completing this assignment

\end{enumerate}

In adherence to the honor code, students should complete this assignment on an individual basis. While it is appropriate
for students in this class to have high-level conversations about the assignment, it is necessary to distinguish
carefully between the student who discusses the principles underlying a problem with others and the student who produces
assignments that are identical to, or merely variations on, someone else's work.  As such, deliverables that are nearly
identical to the work of others will be taken as evidence of violating the \mbox{Honor Code}.  

  \end{document}
